<!DOCTYPE html>
<html lang="en" class="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Telegram - Bot Client</title>
    
    <script src="https://cdn.tailwindcss.com"></script>
    
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans:wght@400;500;600;700&display=swap" rel="stylesheet">
    
    <script>
        tailwind.config = { darkMode: 'class' }
    </script>

    <style>
        body { font-family: 'Noto Sans', sans-serif; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; }
        ::-webkit-scrollbar { width: 6px; height: 6px; }
        .dark ::-webkit-scrollbar-track { background: #1e293b; }
        ::-webkit-scrollbar-thumb { background: #475569; border-radius: 3px; }
        .dark ::-webkit-scrollbar-thumb:hover { background: #64748b; }
        
        #message-input::-webkit-scrollbar { display: none; }
        #message-input { -ms-overflow-style: none; scrollbar-width: none; }

        .grid-background {
            background-color: #0f172a;
            background-image: linear-gradient(white 1px, transparent 1px), linear-gradient(90deg, white 1px, transparent 1px);
            background-size: 40px 40px;
            background-position: -1px -1px;
            opacity: 0.05;
        }

        .message-appear { animation: message-in 0.3s ease-out forwards; }
        @keyframes message-in {
            from { opacity: 0; transform: translateY(20px) scale(0.95); }
            to { opacity: 1; transform: translateY(0) scale(1); }
        }
        
        .context-menu-appear { animation: context-in 0.15s ease-out forwards; }
        @keyframes context-in {
            from { opacity: 0; transform: scale(0.9); }
            to { opacity: 1; transform: scale(1); }
        }
    </style>
</head>
<body class="bg-slate-900 text-slate-300 overflow-hidden">

    <div id="app" class="flex h-[100dvh] w-full relative">

        <!-- Sidebar -->
        <aside id="sidebar" class="w-80 h-full bg-slate-900/80 backdrop-blur-sm border-r border-slate-800 flex flex-col p-4 space-y-4 transition-transform duration-300 ease-in-out
                                   fixed inset-y-0 left-0 z-40 md:relative md:translate-x-0 -translate-x-full">
            <!-- Sidebar Header -->
            <div class="flex items-center justify-between">
                <div class="flex items-center space-x-3">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" class="w-10 h-10"><g><path fill="none" d="M0 0h24v24H0z"></path><path fill="#00abe8" d="M1 12C1 4 4 1 12 1s11 3 11 11-3 11-11 11S1 20 1 12"></path><path fill="#fff" fill-rule="evenodd" d="M17 7 6.25 11.54a.42.42 0 0 0 0 .78l2 .63a2.19 2.19 0 0 0 1.89-.29l4.53-3.13a.16.16 0 0 1 .2.24l-3.47 3.32a.84.84 0 0 0 .11 1.29l3.73 2.52a.84.84 0 0 0 1.29-.56L18 7.8a.73.73 0 0 0-1-.8Z"></path></g></svg>
                    <h1 class="text-xl font-bold text-white">Telegram</h1>
                </div>
                <button id="close-sidebar-btn" class="md:hidden p-1 text-slate-400 hover:text-white"><svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg></button>
            </div>

            <!-- Bot Token Setup -->
            <div class="space-y-2">
                <label for="bot-token" class="text-sm font-medium text-slate-400">Bot Token</label>
                <div class="flex space-x-2">
                    <input type="password" id="bot-token" class="w-full bg-slate-800 border border-slate-700 rounded-md px-3 py-2 text-sm text-white placeholder-slate-500 focus:outline-none focus:ring-2 focus:ring-sky-500 transition" placeholder="Enter your token...">
                    <button id="connect-btn" class="bg-sky-600 hover:bg-sky-700 text-white font-semibold px-4 py-2 rounded-md transition-colors duration-200 whitespace-nowrap">Connect</button>
                </div>
                <div id="bot-status" class="text-xs text-slate-500 h-4 transition-all flex items-center"><span class="w-2 h-2 rounded-full bg-red-500 inline-block mr-2"></span><span>Disconnected</span></div>
            </div>

            <!-- Search User -->
            <div class="space-y-2">
                <label for="search-user" class="text-sm font-medium text-slate-400">Start New Chat</label>
                <div class="flex space-x-2">
                    <input type="number" id="search-user" class="w-full bg-slate-800 border border-slate-700 rounded-md px-3 py-2 text-sm text-white placeholder-slate-500 focus:outline-none focus:ring-2 focus:ring-sky-500 transition" placeholder="User ID">
                    <button id="start-chat-btn" class="bg-slate-700 hover:bg-slate-600 text-white font-semibold px-4 py-2 rounded-md transition-colors duration-200 whitespace-nowrap disabled:opacity-50 disabled:cursor-not-allowed" disabled>Start</button>
                </div>
            </div>

            <!-- Chat List -->
            <div class="flex-grow overflow-y-auto space-y-2 pr-1 -mr-1">
                <h2 class="text-sm font-semibold text-slate-400 border-b border-slate-800 pb-2">Chats</h2>
                <div id="chat-list" class="space-y-1"></div>
            </div>

            <!-- Settings Footer -->
            <div class="flex-shrink-0 border-t border-slate-800 pt-3 flex items-center justify-end">
                <button id="disconnect-btn" class="text-sm text-red-500 hover:text-red-400 font-medium disabled:opacity-50 disabled:cursor-not-allowed" disabled>Disconnect & Forget Token</button>
            </div>
        </aside>

        <!-- Sidebar Overlay for Mobile -->
        <div id="sidebar-overlay" class="fixed inset-0 bg-black/50 z-30 hidden md:hidden" ></div>

        <!-- Main Chat Area -->
        <main class="w-full h-full flex flex-col bg-slate-900 relative">
            <div class="absolute inset-0 grid-background"></div>
            <div class="absolute inset-0 bg-gradient-to-t from-slate-900 via-slate-900/80 to-transparent"></div>
            
            <!-- Chat Header -->
            <header class="relative z-10 flex-shrink-0 flex items-center justify-between p-3 border-b border-slate-800 bg-slate-900/80 backdrop-blur-sm">
                <div class="flex items-center space-x-3">
                    <button id="open-sidebar-btn" class="md:hidden p-1 text-slate-400 hover:text-white"><svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h16"></path></svg></button>
                    <div id="chat-header-info">
                        <h2 id="chat-name" class="text-lg font-semibold text-white">Select a chat</h2>
                        <p id="chat-id-display" class="text-xs text-slate-400"></p>
                    </div>
                </div>
                <button id="clear-chat-btn" class="flex items-center space-x-2 text-sm text-slate-400 hover:text-white hover:bg-slate-700 rounded-md px-3 py-1.5 transition-colors disabled:opacity-50 disabled:cursor-not-allowed" disabled>
                    <svg class="w-4 h-4" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M9 2a1 1 0 00-.894.553L7.382 4H4a1 1 0 000 2v10a2 2 0 002 2h8a2 2 0 002-2V6a1 1 0 100-2h-3.382l-.724-1.447A1 1 0 0011 2H9zM7 8a1 1 0 012 0v6a1 1 0 11-2 0V8zm5-1a1 1 0 00-1 1v6a1 1 0 102 0V8a1 1 0 00-1-1z" clip-rule="evenodd"></path></svg>
                    <span>Clear Chat</span>
                </button>
            </header>

            <!-- Messages Container -->
            <div id="messages-container" class="relative z-10 flex-grow p-4 overflow-y-auto">
                 <div id="message-list" class="flex flex-col gap-4"></div>
            </div>

            <!-- Message Input Form -->
            <footer class="relative z-10 flex-shrink-0 p-3 border-t border-slate-800 bg-slate-900">
                <form id="message-form" class="relative flex items-end">
                    <button type="button" id="attach-file-btn" class="p-2 mr-2 text-slate-400 hover:text-white hover:bg-slate-700 rounded-full transition-colors disabled:opacity-50 disabled:cursor-not-allowed" disabled><svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15.172 7l-6.586 6.586a2 2 0 102.828 2.828l6.414-6.586a4 4 0 00-5.656-5.656l-6.415 6.585a6 6 0 108.486 8.486L20.5 13"></path></svg></button>
                    <input type="file" id="file-input" class="hidden">
                    <textarea id="message-input" rows="1" class="w-full max-h-40 bg-slate-800 border border-slate-700 rounded-lg px-4 py-2.5 text-white placeholder-slate-500 resize-none focus:outline-none focus:ring-2 focus:ring-sky-500 transition disabled:opacity-50" placeholder="Type a message..." disabled></textarea>
                    <button type="submit" id="send-btn" class="p-3 ml-2 bg-sky-600 hover:bg-sky-700 text-white rounded-full transition-colors disabled:opacity-50 disabled:cursor-not-allowed" disabled><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" class="w-6 h-6"><path fill="currentColor" d="m20.665 3.717-17.73 6.837c-1.21.486-1.203 1.161-.222 1.462l4.552 1.42 10.532-6.645c.498-.303.953-.14.579.192l-8.533 7.701h-.002l.002.001-.314 4.692c.46 0 .663-.211.921-.46l2.211-2.15 4.599 3.397c.848.467 1.457.227 1.668-.785l3.019-14.228c.309-1.239-.473-1.8-1.282-1.434z"></path></svg></button>
                    <div id="file-preview" class="absolute bottom-full right-0 mb-2 p-2 bg-slate-700 rounded-lg text-sm hidden items-center space-x-2 shadow-md">
                        <span id="file-name" class="text-slate-200"></span>
                        <button type="button" id="remove-file-btn" class="text-red-400 hover:text-red-300">×</button>
                    </div>
                </form>
            </footer>
        </main>
    </div>

    <!-- Popups and Menus -->
    <div id="popups-container" class="fixed inset-0 z-50 pointer-events-none">
        <div id="message-action-menu" class="hidden absolute bg-slate-800/90 backdrop-blur-sm shadow-lg rounded-md text-sm font-medium p-1 context-menu-appear pointer-events-auto"></div>
        <div id="chat-context-menu" class="hidden absolute bg-slate-800/90 backdrop-blur-sm shadow-lg rounded-md text-sm font-medium p-1 context-menu-appear pointer-events-auto"></div>
        <div id="info-modal" class="hidden fixed inset-0 bg-black/60 flex items-center justify-center pointer-events-auto">
            <div class="bg-slate-800 rounded-lg shadow-xl p-6 w-full max-w-md context-menu-appear">
                <h3 class="text-lg font-bold text-white mb-4">User Information</h3>
                <pre class="text-xs bg-slate-900 p-4 rounded-md overflow-x-auto text-slate-300"></pre>
                <button id="close-info-modal-btn" class="mt-6 w-full bg-sky-600 hover:bg-sky-700 text-white font-semibold py-2 rounded-md transition-colors">Close</button>
            </div>
        </div>
    </div>

    <script>
    document.addEventListener('DOMContentLoaded', () => {
        // --- STATE & CONSTANTS ---
        let botToken = null, botInfo = {}, currentChatId = null, updateOffset = 0, chats = {}, getUpdatesController = null, audioBlobs = {};
        const EMPTY_CHAT_PLACEHOLDER = `<div id="empty-chat-placeholder" class="flex flex-col justify-center items-center h-full text-center text-slate-500"><svg class="w-24 h-24" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="1" d="M8 12h.01M12 12h.01M16 12h.01M21 12c0 4.418-4.03 8-9 8a9.863 9.863 0 01-4.255-.949L3 20l1.395-3.72C3.512 15.042 3 13.574 3 12c0-4.418 4.03-8 9-8s9 3.582 9 8z"></path></svg><p class="mt-4 text-lg">Select a chat to start messaging</p></div>`;

        // --- DOM ELEMENTS ---
        const sidebar = document.getElementById('sidebar'), sidebarOverlay = document.getElementById('sidebar-overlay'), openSidebarBtn = document.getElementById('open-sidebar-btn'), closeSidebarBtn = document.getElementById('close-sidebar-btn');
        const botTokenInput = document.getElementById('bot-token'), connectBtn = document.getElementById('connect-btn'), disconnectBtn = document.getElementById('disconnect-btn'), botStatus = document.getElementById('bot-status');
        const searchUserInput = document.getElementById('search-user'), startChatBtn = document.getElementById('start-chat-btn'), chatList = document.getElementById('chat-list');
        const chatName = document.getElementById('chat-name'), chatIdDisplay = document.getElementById('chat-id-display'), clearChatBtn = document.getElementById('clear-chat-btn');
        const messagesContainer = document.getElementById('messages-container'), messageList = document.getElementById('message-list');
        const messageForm = document.getElementById('message-form'), messageInput = document.getElementById('message-input'), sendBtn = document.getElementById('send-btn');
        const attachFileBtn = document.getElementById('attach-file-btn'), fileInput = document.getElementById('file-input'), filePreview = document.getElementById('file-preview'), fileNameEl = document.getElementById('file-name'), removeFileBtn = document.getElementById('remove-file-btn');
        const messageActionMenu = document.getElementById('message-action-menu'), chatContextMenu = document.getElementById('chat-context-menu'), infoModal = document.getElementById('info-modal'), infoModalContent = document.querySelector('#info-modal pre'), closeInfoModalBtn = document.getElementById('close-info-modal-btn');

        // --- API & HELPERS ---
        const telegramApi = (method, params = {}) => {
            if (!botToken) return Promise.reject('No token');
            const url = `https://api.telegram.org/bot${botToken}/${method}`;
            const options = { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(params) };
            if (params instanceof FormData) { delete options.headers; options.body = params; }
            return fetch(url, options).then(res => res.json());
        };
        const getFileUrl = async (fileId) => {
            try {
                const res = await telegramApi('getFile', { file_id: fileId });
                return res.ok ? `https://api.telegram.org/file/bot${botToken}/${res.result.file_path}` : null;
            } catch (e) { return null; }
        };
        // --- الكود الجديد (المُصحح) ---
const downloadFile = async (fileId, fileName) => {
    const url = await getFileUrl(fileId);
    if (!url) {
        alert('Could not get file URL. Please try again.');
        return;
    }

    try {
        // Create a temporary link element
        const link = document.createElement('a');
        link.href = url;

        // The 'download' attribute is crucial. It tells the browser to download the file
        // instead of navigating to it.
        link.setAttribute('download', fileName || 'download');

        // We need to append the link to the body for it to be clickable in some browsers
        document.body.appendChild(link);

        // Programmatically click the link to trigger the download
        link.click();

        // Clean up by removing the temporary link
        document.body.removeChild(link);

    } catch (e) {
        console.error('Download initiation failed:', e);
        alert('Download failed. Your browser might be blocking the download.');
    }
};
        const escapeHTML = (str) => str.replace(/[&<>'"]/g, tag => ({'&': '&', '<': '<', '>': '>', "'": '\'', '"': '"'}[tag] || tag));
        const saveChatsToStorage = () => {
            const chatsToSave = {};
            for (const id in chats) { chatsToSave[id] = chats[id].info; }
            localStorage.setItem('savedChatsInfo', JSON.stringify(chatsToSave));
        };

        // --- UI & RENDER ---
        const toggleSidebar = (open) => {
            sidebar.classList.toggle('-translate-x-full', !open);
            sidebarOverlay.classList.toggle('hidden', !open);
        };
        const updateBotStatus = (connected, info = {}) => {
            const statusIndicator = botStatus.querySelector('span:first-child'), statusText = botStatus.querySelector('span:last-child');
            if (connected) {
                botInfo = info;
                statusIndicator.classList.replace('bg-red-500', 'bg-green-500');
                statusText.textContent = `Connected as @${info.username}`;
                [botTokenInput, connectBtn].forEach(el => el.disabled = true);
                connectBtn.textContent = 'Connected';
                disconnectBtn.disabled = false;
                enableChatUI(true);
            } else {
                botInfo = {};
                statusIndicator.classList.replace('bg-green-500', 'bg-red-500');
                statusText.textContent = 'Disconnected';
                [botTokenInput, connectBtn].forEach(el => el.disabled = false);
                botTokenInput.value = '';
                connectBtn.textContent = 'Connect';
                disconnectBtn.disabled = true;
                enableChatUI(false);
                if (getUpdatesController) getUpdatesController.abort();
            }
        };
        const enableChatUI = (enabled) => [startChatBtn, messageInput, sendBtn, attachFileBtn, clearChatBtn].forEach(el => el.disabled = !enabled);
        const renderChatList = () => {
            chatList.innerHTML = '';
            const sortedChatIds = Object.keys(chats).sort((a, b) => (chats[b].messages.at(-1)?.date || 0) - (chats[a].messages.at(-1)?.date || 0));
            if (sortedChatIds.length === 0) { chatList.innerHTML = `<p class="text-center text-sm text-slate-500 py-4">No active chats.</p>`; return; }
            sortedChatIds.forEach(chatId => {
                const chat = chats[chatId], chatInfo = chat.info, lastMessage = chat.messages.at(-1);
                const name = chatInfo.id == botInfo.id ? "Saved Messages" : (chatInfo.first_name ? `${chatInfo.first_name} ${chatInfo.last_name || ''}`.trim() : chatInfo.username || `User ${chatInfo.id}`);
                const lastMsgText = lastMessage ? (lastMessage.text || 'Attachment') : 'No messages yet';
                const chatItem = document.createElement('div');
                chatItem.className = `flex items-center p-2 rounded-lg cursor-pointer transition-colors group ${chatId == currentChatId ? 'bg-sky-900/50' : 'hover:bg-slate-800'}`;
                chatItem.dataset.chatId = chatId;
                chatItem.innerHTML = `<div class="w-10 h-10 bg-slate-700 rounded-full flex items-center justify-center font-bold text-sky-400 flex-shrink-0 mr-3">${name.charAt(0).toUpperCase()}</div><div class="flex-grow overflow-hidden"><p class="font-semibold text-white truncate">${name}</p><p class="text-sm text-slate-400 truncate">${lastMsgText}</p></div><button class="chat-menu-btn p-1 rounded-full text-slate-500 hover:bg-slate-700 opacity-0 group-hover:opacity-100 transition-opacity" data-chat-id="${chatId}"><svg class="w-5 h-5" fill="currentColor" viewBox="0 0 20 20"><path d="M10 6a2 2 0 110-4 2 2 0 010 4zM10 12a2 2 0 110-4 2 2 0 010 4zM10 18a2 2 0 110-4 2 2 0 010 4z"></path></svg></button>`;
                chatItem.querySelector('.chat-menu-btn').addEventListener('click', (e) => { e.stopPropagation(); showChatContextMenu(e.currentTarget); });
                chatItem.addEventListener('click', () => { openChat(chatId); if (window.innerWidth < 768) toggleSidebar(false); });
                chatList.appendChild(chatItem);
            });
        };
        const renderChat = (chatId) => {
            const chat = chats[chatId];
            if (!chat) return;
            const chatInfo = chat.info;
            const name = chatInfo.id == botInfo.id ? "Saved Messages" : (chatInfo.first_name ? `${chatInfo.first_name} ${chatInfo.last_name || ''}`.trim() : chatInfo.username || `User ${chatInfo.id}`);
            chatName.textContent = name;
            chatIdDisplay.textContent = `ID: ${chatInfo.id}`;
            clearChatBtn.disabled = false;
            messageList.innerHTML = '';
            if (chat.messages.length === 0) {
                messageList.innerHTML = EMPTY_CHAT_PLACEHOLDER.replace('Select a chat', 'No messages yet');
            } else {
                chat.messages.forEach(msg => appendMessageToUI(msg, false));
            }
            messagesContainer.scrollTop = messagesContainer.scrollHeight;
        };
        const appendMessageToUI = async (msg, animate = true, tempId = null) => {
            document.getElementById('empty-chat-placeholder')?.remove();
            const isBotMessage = msg.from.id === botInfo.id;
            const messageWrapper = document.createElement('div');
            messageWrapper.className = `flex items-end gap-2 ${isBotMessage ? 'justify-end' : 'justify-start'} ${animate ? 'message-appear' : ''} group`;
            const messageBubble = document.createElement('div');
            messageBubble.className = `relative max-w-md lg:max-w-2xl p-1 rounded-lg ${isBotMessage ? 'bg-sky-600 text-white' : 'bg-slate-700 text-slate-200'}`;
            let contentHTML = '', metaHTML = '', actionsHTML = '';
            if (msg.photo) {
                const url = await getFileUrl(msg.photo.at(-1).file_id);
                contentHTML = `<img src="${url}" alt="Photo" class="rounded-md max-w-xs max-h-80 object-cover cursor-pointer" loading="lazy" onclick="window.open('${url}')">`;
            } else if (msg.video) {
                const url = await getFileUrl(msg.video.file_id);
                contentHTML = `<video src="${url}" controls class="rounded-md max-w-xs"></video>`;
            } else if (msg.audio) {
                const url = await getFileUrl(msg.audio.file_id), res = await fetch(url), blob = await res.blob(), blobUrl = URL.createObjectURL(blob);
                audioBlobs[msg.message_id] = blobUrl;
                contentHTML = `<audio src="${blobUrl}" controls class="w-64"></audio>`;
            } else if (msg.document) {
                const doc = msg.document, thumbUrl = doc.thumb ? await getFileUrl(doc.thumb.file_id) : null;
                let thumbHTML = thumbUrl ? `<img src="${thumbUrl}" class="w-16 h-16 object-cover rounded-md bg-slate-800">` : `<div class="w-16 h-16 flex items-center justify-center bg-slate-800 rounded-md"><svg class="w-8 h-8 text-sky-400" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 21h10a2 2 0 002-2V9.414a1 1 0 00-.293-.707l-5.414-5.414A1 1 0 0012.586 3H7a2 2 0 00-2 2v14a2 2 0 002 2z"></path></svg></div>`;
                contentHTML = `<div class="flex items-center gap-3 p-2">${thumbHTML}<div class="flex-grow"><p class="font-medium break-all">${escapeHTML(doc.file_name)}</p><p class="text-xs text-slate-400">${(doc.file_size / 1024).toFixed(1)} KB</p></div></div>`;
            }
            const text = msg.text || msg.caption;
            if (text) contentHTML += `<div class="px-3 py-2 whitespace-pre-wrap break-words">${escapeHTML(text)}</div>`;
            const time = new Date(msg.date * 1000).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
            metaHTML = `<div class="text-xs ${isBotMessage ? 'text-sky-200' : 'text-slate-400'} mt-1 text-right px-2 pb-1">${time}</div>`;
            if (!isBotMessage && (msg.photo || msg.video || msg.audio || msg.document)) {
                const file = msg.photo?.at(-1) || msg.video || msg.audio || msg.document;
                actionsHTML = `<div class="p-2"><button class="download-btn w-full flex items-center justify-center gap-2 text-sm bg-slate-600 hover:bg-slate-500 rounded-md py-1.5" data-file-id="${file.file_id}" data-file-name="${file.file_name || 'download'}"><svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4"></path></svg><span>Download</span></button></div>`;
            }
            messageBubble.innerHTML = contentHTML + metaHTML + actionsHTML;
            if (isBotMessage) {
                const moreBtnHTML = `<button class="message-action-btn p-1 rounded-full text-slate-400 hover:text-white opacity-0 group-hover:opacity-100 transition-opacity" data-message-id="${msg.message_id}" data-chat-id="${msg.chat.id}"><svg class="w-5 h-5" fill="currentColor" viewBox="0 0 20 20"><path d="M10 6a2 2 0 110-4 2 2 0 010 4zM10 12a2 2 0 110-4 2 2 0 010 4zM10 18a2 2 0 110-4 2 2 0 010 4z"></path></svg></button>`;
                messageWrapper.appendChild(messageBubble);
                messageWrapper.insertAdjacentHTML('afterbegin', moreBtnHTML);
            } else {
                messageWrapper.appendChild(messageBubble);
            }
            if (tempId) {
                const pendingEl = document.getElementById(tempId);
                if (pendingEl) pendingEl.replaceWith(messageWrapper);
            } else {
                messageList.appendChild(messageWrapper);
            }
            if (animate) messagesContainer.scrollTop = messagesContainer.scrollHeight;
        };

        // --- CORE LOGIC & EVENT HANDLERS ---
        const handleConnect = async () => {
            const token = botTokenInput.value.trim();
            if (!token) { alert('Please enter a bot token.'); return; }
            botToken = token;
            try {
                const res = await telegramApi('getMe');
                if (res.ok) {
                    localStorage.setItem('botToken', token);
                    updateBotStatus(true, res.result);
                    getUpdatesLoop();
                    addChat(res.result);
                    const savedMessagesId = res.result.id;
                    if (savedMessagesId && chats[savedMessagesId]) {
                        openChat(savedMessagesId);
                    }
                } else { botToken = null; alert(`Connection failed: ${res.description}`); updateBotStatus(false); }
            } catch (error) { botToken = null; alert('A network error occurred.'); updateBotStatus(false); }
        };
        const handleDisconnect = () => {
            if (confirm('Are you sure you want to disconnect and forget the token?')) {
                localStorage.removeItem('botToken');
                localStorage.removeItem('lastChatId');
                localStorage.removeItem('savedChatsInfo');
                botToken = null;
                updateBotStatus(false);
                chats = {};
                currentChatId = null;
                renderChatList();
                messageList.innerHTML = EMPTY_CHAT_PLACEHOLDER;
                chatName.textContent = 'Select a chat';
                chatIdDisplay.textContent = '';
            }
        };
        const addChat = (chatInfo) => {
            if (!chats[chatInfo.id]) {
                chats[chatInfo.id] = { info: chatInfo, messages: [] };
                renderChatList();
                saveChatsToStorage();
            }
        };
        const openChat = (chatId) => {
            currentChatId = chatId;
            localStorage.setItem('lastChatId', chatId);
            renderChat(chatId);
            renderChatList();
        };
        const handleStartChat = async () => {
            const targetId = searchUserInput.value.trim();
            if (!targetId || isNaN(targetId)) { alert('Please enter a valid numeric User ID.'); return; }
            if (!chats[targetId]) {
                try {
                    const chatInfo = await telegramApi('getChat', { chat_id: targetId });
                    addChat(chatInfo.ok ? chatInfo.result : { id: targetId, first_name: `User ${targetId}` });
                } catch (e) { addChat({ id: targetId, first_name: `User ${targetId}` }); }
            }
            openChat(targetId);
            searchUserInput.value = '';
            if (window.innerWidth < 768) toggleSidebar(false);
        };
        const handleSendMessage = async (e) => {
            e.preventDefault();
            const text = messageInput.value.trim(), file = fileInput.files[0];
            if ((!text && !file) || !currentChatId) return;
            messageInput.value = ''; messageInput.style.height = 'auto'; handleRemoveFile();
            if (!file) {
                try {
                    const res = await telegramApi('sendMessage', { chat_id: currentChatId, text: text });
                    if (res.ok) { chats[currentChatId].messages.push(res.result); appendMessageToUI(res.result); renderChatList(); } 
                    else { alert(`Failed to send message: ${res.description}`); }
                } catch (error) { alert('An error occurred while sending the message.'); }
                return;
            }
            // File upload with progress
            const tempId = `pending-${Date.now()}`;
            const filePreviewURL = URL.createObjectURL(file);
            let previewHTML = `<img src="${filePreviewURL}" class="rounded-md max-w-xs max-h-80 object-cover">`;
            if (file.type.startsWith('video/')) previewHTML = `<video src="${filePreviewURL}" class="rounded-md max-w-xs"></video>`;
            const pendingMessageHTML = `<div id="${tempId}" class="flex items-end gap-2 justify-end message-appear group"><div class="relative max-w-md lg:max-w-2xl p-1 rounded-lg bg-sky-600 text-white">${previewHTML}${text ? `<div class="px-3 py-2 whitespace-pre-wrap break-words">${escapeHTML(text)}</div>` : ''}<div class="p-2"><div class="progress-bar h-1.5 bg-sky-400/30 rounded-full"><div class="progress-bar-fill h-full bg-sky-300 rounded-full w-0 transition-all duration-300"></div></div><p class="progress-text text-xs text-sky-200 text-center mt-1">Uploading 0%</p></div></div></div>`;
            document.getElementById('empty-chat-placeholder')?.remove();
            messageList.insertAdjacentHTML('beforeend', pendingMessageHTML);
            messagesContainer.scrollTop = messagesContainer.scrollHeight;

            const formData = new FormData();
            formData.append('chat_id', currentChatId);
            const fileType = file.type.split('/')[0];
            let method = 'sendDocument', fieldName = 'document';
            if (fileType === 'image') { method = 'sendPhoto'; fieldName = 'photo'; }
            if (fileType === 'video') { method = 'sendVideo'; fieldName = 'video'; }
            if (fileType === 'audio') { method = 'sendAudio'; fieldName = 'audio'; }
            formData.append(fieldName, file);
            if (text) formData.append('caption', text);

            const xhr = new XMLHttpRequest();
            xhr.open('POST', `https://api.telegram.org/bot${botToken}/${method}`, true);
            xhr.upload.onprogress = (event) => {
                if (event.lengthComputable) {
                    const percent = Math.round((event.loaded / event.total) * 100);
                    const pendingEl = document.getElementById(tempId);
                    if (pendingEl) {
                        pendingEl.querySelector('.progress-bar-fill').style.width = `${percent}%`;
                        pendingEl.querySelector('.progress-text').textContent = `Uploading ${percent}%`;
                    }
                }
            };
            xhr.onload = () => {
                URL.revokeObjectURL(filePreviewURL);
                const pendingEl = document.getElementById(tempId);
                if (xhr.status === 200) {
                    const res = JSON.parse(xhr.responseText);
                    if (res.ok) {
                        chats[currentChatId].messages.push(res.result);
                        appendMessageToUI(res.result, true, tempId);
                        renderChatList();
                    } else {
                        if (pendingEl) pendingEl.querySelector('.progress-text').textContent = `Failed: ${res.description}`;
                        if (pendingEl) pendingEl.querySelector('.progress-bar-fill').classList.add('bg-red-500');
                    }
                } else {
                    if (pendingEl) pendingEl.querySelector('.progress-text').textContent = `Upload Error: ${xhr.statusText}`;
                    if (pendingEl) pendingEl.querySelector('.progress-bar-fill').classList.add('bg-red-500');
                }
            };
            xhr.onerror = () => {
                URL.revokeObjectURL(filePreviewURL);
                const pendingEl = document.getElementById(tempId);
                if (pendingEl) {
                    pendingEl.querySelector('.progress-text').textContent = 'Network Error';
                    pendingEl.querySelector('.progress-bar-fill').classList.add('bg-red-500');
                }
            };
            xhr.send(formData);
        };
        const getUpdatesLoop = async () => {
            if (!botToken) return;
            if (getUpdatesController) getUpdatesController.abort();
            getUpdatesController = new AbortController();
            try {
                const res = await fetch(`https://api.telegram.org/bot${botToken}/getUpdates?offset=${updateOffset}&timeout=30`, { signal: getUpdatesController.signal });
                const data = await res.json();
                if (data.ok && data.result.length > 0) {
                    for (const update of data.result) {
                        if (update.message) {
                            const msg = update.message, chatId = msg.chat.id;
                            if (!chats[chatId]) addChat(msg.chat);
                            chats[chatId].messages.push(msg);
                            if (chatId == currentChatId) await appendMessageToUI(msg);
                            renderChatList();
                        }
                        updateOffset = update.update_id + 1;
                    }
                }
            } catch (error) { if (error.name !== 'AbortError') await new Promise(resolve => setTimeout(resolve, 5000)); } 
            finally { if (botToken) getUpdatesLoop(); }
        };
        const handleEditMessage = async (messageId, chatId) => {
            const originalMessage = chats[chatId]?.messages.find(m => m.message_id == messageId);
            if (!originalMessage) return;
            const newText = prompt('Enter new text:', originalMessage.text);
            if (newText === null || newText === originalMessage.text) return;
            try {
                const res = await telegramApi('editMessageText', { chat_id: chatId, message_id: messageId, text: newText });
                if (res.ok) { originalMessage.text = newText; renderChat(chatId); } 
                else { alert(`Failed to edit message: ${res.description}`); }
            } catch (error) { alert('An error occurred while editing.'); }
        };
        const handleDeleteMessage = async (messageId, chatId) => {
            if (!confirm('Are you sure you want to delete this message?')) return;
            try {
                const res = await telegramApi('deleteMessage', { chat_id: chatId, message_id: messageId });
                if (res.ok) {
                    chats[chatId].messages = chats[chatId].messages.filter(m => m.message_id != messageId);
                    renderChat(chatId);
                } else { alert(`Failed to delete message: ${res.description}`); }
            } catch (error) { alert('An error occurred while deleting.'); }
        };
        const handleClearChat = (chatId) => {
            if (!chatId || !chats[chatId] || !confirm(`Are you sure you want to clear all messages in this chat?`)) return;
            chats[chatId].messages.forEach(msg => { if (audioBlobs[msg.message_id]) { URL.revokeObjectURL(audioBlobs[msg.message_id]); delete audioBlobs[msg.message_id]; } });
            chats[chatId].messages = [];
            renderChat(chatId);
            renderChatList();
        };
        const handleDeleteChat = (chatId) => {
            if (!chatId || !chats[chatId] || !confirm(`Are you sure you want to delete this chat? This cannot be undone.`)) return;
            handleClearChat(chatId);
            delete chats[chatId];
            saveChatsToStorage();
            if (currentChatId == chatId) {
                currentChatId = null;
                localStorage.removeItem('lastChatId');
                messageList.innerHTML = EMPTY_CHAT_PLACEHOLDER;
                chatName.textContent = 'Select a chat';
                chatIdDisplay.textContent = '';
            }
            renderChatList();
        };
        const handleShowInfo = (chatId) => {
            const info = chats[chatId]?.info;
            if (!info) return;
            infoModalContent.textContent = JSON.stringify(info, null, 2);
            infoModal.classList.remove('hidden');
        };
        const handleFileChange = () => {
            const file = fileInput.files[0];
            if (file) {
                fileNameEl.textContent = file.name.length > 20 ? file.name.substring(0, 17) + '...' : file.name;
                filePreview.classList.remove('hidden');
                filePreview.classList.add('flex');
            } else { handleRemoveFile(); }
        };
        const handleRemoveFile = () => {
            fileInput.value = '';
            filePreview.classList.add('hidden');
            filePreview.classList.remove('flex');
        };
        const showMessageActionMenu = (button) => {
            const rect = button.getBoundingClientRect();
            messageActionMenu.innerHTML = `<button data-action="edit" class="w-full text-left px-3 py-1.5 rounded hover:bg-slate-700 text-slate-200 transition-colors flex items-center space-x-2"><svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15.232 5.232l3.536 3.536m-2.036-5.036a2.5 2.5 0 113.536 3.536L6.5 21.036H3v-3.536L16.732 3.732z"></path></svg> <span>Edit</span></button><button data-action="delete" class="w-full text-left px-3 py-1.5 rounded hover:bg-slate-700 text-red-400 transition-colors flex items-center space-x-2"><svg class="w-4 h-4" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M9 2a1 1 0 00-.894.553L7.382 4H4a1 1 0 000 2v10a2 2 0 002 2h8a2 2 0 002-2V6a1 1 0 100-2h-3.382l-.724-1.447A1 1 0 0011 2H9zM7 8a1 1 0 012 0v6a1 1 0 11-2 0V8zm5-1a1 1 0 00-1 1v6a1 1 0 102 0V8a1 1 0 00-1-1z" clip-rule="evenodd"></path></svg> <span>Delete</span></button>`;
            messageActionMenu.style.top = `${rect.top}px`;
            messageActionMenu.style.left = `${rect.left - messageActionMenu.offsetWidth - 8}px`;
            messageActionMenu.dataset.messageId = button.dataset.messageId;
            messageActionMenu.dataset.chatId = button.dataset.chatId;
            messageActionMenu.classList.remove('hidden');
        };
        const showChatContextMenu = (button) => {
            const rect = button.getBoundingClientRect();
            chatContextMenu.innerHTML = `<button data-action="info" class="w-full text-left px-3 py-1.5 rounded hover:bg-slate-700 text-slate-200 transition-colors flex items-center space-x-2"><svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg> <span>Info</span></button><button data-action="clear" class="w-full text-left px-3 py-1.5 rounded hover:bg-slate-700 text-slate-200 transition-colors flex items-center space-x-2"><svg class="w-4 h-4" fill="currentColor" viewBox="0 0 20 20"><path d="M6 2a2 2 0 00-2 2v12a2 2 0 002 2h8a2 2 0 002-2V4a2 2 0 00-2-2H6zM5 4a1 1 0 011-1h8a1 1 0 011 1v12a1 1 0 01-1 1H6a1 1 0 01-1-1V4z"></path><path d="M8 8a1 1 0 011-1h2a1 1 0 110 2H9a1 1 0 01-1-1z"></path></svg> <span>Clear History</span></button><button data-action="delete" class="w-full text-left px-3 py-1.5 rounded hover:bg-slate-700 text-red-400 transition-colors flex items-center space-x-2"><svg class="w-4 h-4" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M9 2a1 1 0 00-.894.553L7.382 4H4a1 1 0 000 2v10a2 2 0 002 2h8a2 2 0 002-2V6a1 1 0 100-2h-3.382l-.724-1.447A1 1 0 0011 2H9zM7 8a1 1 0 012 0v6a1 1 0 11-2 0V8zm5-1a1 1 0 00-1 1v6a1 1 0 102 0V8a1 1 0 00-1-1z" clip-rule="evenodd"></path></svg> <span>Delete Chat</span></button>`;
            chatContextMenu.style.top = `${rect.bottom + 4}px`;
            chatContextMenu.style.left = `${rect.left}px`;
            chatContextMenu.dataset.chatId = button.dataset.chatId;
            chatContextMenu.classList.remove('hidden');
        };
        const hideAllMenus = () => { messageActionMenu.classList.add('hidden'); chatContextMenu.classList.add('hidden'); };

        // --- EVENT LISTENERS ---
        openSidebarBtn.addEventListener('click', () => toggleSidebar(true));
        closeSidebarBtn.addEventListener('click', () => toggleSidebar(false));
        sidebarOverlay.addEventListener('click', () => toggleSidebar(false));
        connectBtn.addEventListener('click', handleConnect);
        disconnectBtn.addEventListener('click', handleDisconnect);
        [botTokenInput, searchUserInput].forEach(el => el.addEventListener('keypress', (e) => e.key === 'Enter' && (el.id === 'bot-token' ? handleConnect() : handleStartChat())));
        startChatBtn.addEventListener('click', handleStartChat);
        messageForm.addEventListener('submit', handleSendMessage);
        clearChatBtn.addEventListener('click', () => handleClearChat(currentChatId));
        attachFileBtn.addEventListener('click', () => fileInput.click());
        fileInput.addEventListener('change', handleFileChange);
        removeFileBtn.addEventListener('click', handleRemoveFile);
        messageList.addEventListener('click', (e) => {
            const actionBtn = e.target.closest('.message-action-btn'), downloadBtn = e.target.closest('.download-btn');
            if (actionBtn) showMessageActionMenu(actionBtn);
            else if (downloadBtn) downloadFile(downloadBtn.dataset.fileId, downloadBtn.dataset.fileName);
        });
        messageActionMenu.addEventListener('click', (e) => {
            const button = e.target.closest('button'); if (!button) return;
            const { action } = button.dataset, { messageId, chatId } = messageActionMenu.dataset;
            if (action === 'edit') handleEditMessage(messageId, chatId);
            if (action === 'delete') handleDeleteMessage(messageId, chatId);
            hideAllMenus();
        });
        chatContextMenu.addEventListener('click', (e) => {
            const button = e.target.closest('button'); if (!button) return;
            const { action } = button.dataset, { chatId } = chatContextMenu.dataset;
            if (action === 'info') handleShowInfo(chatId);
            if (action === 'clear') handleClearChat(chatId);
            if (action === 'delete') handleDeleteChat(chatId);
            hideAllMenus();
        });
        closeInfoModalBtn.addEventListener('click', () => infoModal.classList.add('hidden'));
        infoModal.addEventListener('click', (e) => { if (e.target === infoModal) infoModal.classList.add('hidden'); });
        window.addEventListener('click', (e) => { if (!e.target.closest('.message-action-btn, #message-action-menu, .chat-menu-btn, #chat-context-menu')) hideAllMenus(); }, true);
        messageInput.addEventListener('input', () => { messageInput.style.height = 'auto'; messageInput.style.height = (messageInput.scrollHeight) + 'px'; });
        
        // --- INITIALIZATION ---
        const savedChatsInfo = JSON.parse(localStorage.getItem('savedChatsInfo') || '{}');
        for (const id in savedChatsInfo) { chats[id] = { info: savedChatsInfo[id], messages: [] }; }
        renderChatList();
        const savedToken = localStorage.getItem('botToken');
        if (savedToken) { botTokenInput.value = savedToken; handleConnect(); } 
        else { enableChatUI(false); messageList.innerHTML = EMPTY_CHAT_PLACEHOLDER.replace('Select a chat', 'Welcome! Enter your bot token'); }
    });
    </script>
</body>
</html>
